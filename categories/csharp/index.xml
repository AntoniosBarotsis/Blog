<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Csharp on My Blog</title>
    <link>https://antoniosbarotsis.github.io/Blog/categories/csharp/</link>
    <description>Recent content in Csharp on My Blog</description>
    <image>
      <url>https://antoniosbarotsis.github.io/Blog/papermod-cover.png</url>
      <link>https://antoniosbarotsis.github.io/Blog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Oct 2021 16:12:35 +0200</lastBuildDate><atom:link href="https://antoniosbarotsis.github.io/Blog/categories/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Testing an ASP .NET Core project</title>
      <link>https://antoniosbarotsis.github.io/Blog/posts/aspnet_testing/</link>
      <pubDate>Fri, 29 Oct 2021 16:12:35 +0200</pubDate>
      
      <guid>https://antoniosbarotsis.github.io/Blog/posts/aspnet_testing/</guid>
      <description>Tests and automated coverage reports with .NET and Github actions</description>
      <content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Most Web API templates I could find online do not have testing pre configured in them and the official ones do not have it at all so I thought
that I would make a post about setting up basic unit tests as well as mocking dependencies.</p>
<p>I will be using <a href="https://xunit.net/">XUnit</a> which is one of the most used testing frameworks for .NET as well as
<a href="https://fakeiteasy.github.io/">FakeItEasy</a> for mocking. In the end I will also use <a href="https://dotnetfoundation.org/projects/coverlet">Coverlet</a>
and <a href="https://about.codecov.io/">Codecov</a> for coverage reports.</p>
<p>The API will be the weather forecast template with the addition of a service layer which is what we will be testing. Let&rsquo;s get started!</p>
<h1 id="coding">Coding</h1>
<h2 id="creating-the-project">Creating the project</h2>
<p>I will be creating a solution with 2 projects, one being the API and the other one being the one for testing.</p>
<p>We start by creating a folder for the solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir TestingAPI
cd TestingAPI
dotnet new sln
</code></pre></div><p>We can now create the API project and add it to our solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dotnet new webapi -n src
dotnet sln add src/src.csproj
</code></pre></div><p>Similarly for our test project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dotnet new xunit -n test
dotnet sln add test/test.csproj
</code></pre></div><p>Running <code>dotnet run --project src</code> should spin up the server and sure enough, visiting <code>https://localhost:5001/weatherforecast</code>
returns us the expected responce.</p>
<h2 id="creating-the-service">Creating the service</h2>
<p>I will create a <code>Services</code> folder and inside it add 2 files: a service interface and its implementation</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// IMyDependency.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Threading.Tasks;

<span style="color:#66d9ef">namespace</span> src.Services
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IMyDependency
    {
        Task&lt;<span style="color:#66d9ef">string</span>&gt; GetDataFromDatabaseAsync();
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// MyDependency.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Threading.Tasks;

<span style="color:#66d9ef">namespace</span> src.Services
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDependency</span>: IMyDependency
    {
        <span style="color:#66d9ef">public</span> Task&lt;<span style="color:#66d9ef">string</span>&gt; GetDataFromDatabaseAsync()
        {
            <span style="color:#66d9ef">return</span> Task.FromResult(<span style="color:#e6db74">&#34;Hello From MyDependency!&#34;</span>);
        }
    }
}
</code></pre></div><p>Let&rsquo;s head to our controller and make use of the service we just created there so we can make sure it works:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// WeatherForecastController.cs
</span><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger&lt;WeatherForecastController&gt; <span style="color:#ae81ff">_l</span>ogger;
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IMyDependency <span style="color:#ae81ff">_d</span>ependency;

<span style="color:#66d9ef">public</span> WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger, IMyDependency dependency)
{
    <span style="color:#ae81ff">_l</span>ogger = logger;
    <span style="color:#ae81ff">_d</span>ependency = dependency;
}
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#a6e22e">
</span><span style="color:#a6e22e">[HttpGet]</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get()
{
    <span style="color:#ae81ff">_l</span>ogger.LogInformation(<span style="color:#66d9ef">await</span> <span style="color:#ae81ff">_d</span>ependency.GetDataFromDatabaseAsync());
    
    <span style="color:#75715e">// No changes below this
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> rng = <span style="color:#66d9ef">new</span> Random();
    <span style="color:#66d9ef">return</span> Enumerable.Range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>).Select(index =&gt; <span style="color:#66d9ef">new</span> WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = rng.Next(-<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">55</span>),
        Summary = Summaries[rng.Next(Summaries.Length)]
    })
    .ToArray();
}
</code></pre></div><p>Lastly we head to <code>Startup.cs</code> to register the implementation</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// Startup.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    services.AddScoped&lt;IMyDependency, MyDependency&gt;();
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>If we now run the app and hit the endpoint we should see <code>Hello From MyDependency!</code> logged in the console.</p>
<h2 id="writing-our-tests">Writing our tests</h2>
<p>Let&rsquo;s navigate to our test project and write our first test</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// UnitTest1.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> FakeItEasy;
<span style="color:#66d9ef">using</span> src.Services;
<span style="color:#66d9ef">using</span> Xunit;

<span style="color:#66d9ef">namespace</span> test
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnitTest1</span>
    {
<span style="color:#a6e22e">        [Fact]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task Test1()
        {
            <span style="color:#66d9ef">var</span> myDependency = <span style="color:#66d9ef">new</span> MyDependency();
            Assert.Equal(<span style="color:#e6db74">&#34;Hello From MyDependency!&#34;</span>, <span style="color:#66d9ef">await</span> myDependency.GetDataFromDatabaseAsync());
        }
    }
}
</code></pre></div><p>Here I changed the return type from <code>void</code> to <code>async Task</code> since the method we want to test is async. Running the test with
<code>dotnet test</code> passes but this is not what we want.</p>
<p>In a normal project this method could require a database connection that we probably do not want to make use of in our tests for various reasons.
This is where mocking comes into play; we can provide a fake implementation to our service methods. It might not be as apparent here why this could
be useful so let me explain.</p>
<p>Usually the way I like to structure my apps is to split them into 3 layers</p>
<ul>
<li>Controllers: handle http requests, call service layer</li>
<li>Services: business logic, call repository layer</li>
<li>Repositories: Handle database queries</li>
</ul>
<p>Coming from a Spring Boot background, my terminology might be a bit different than what is normally used for .NET projects but the idea is the same;
split your logic into layers and use dependency injection to interact between them.</p>
<p>The most important layer to test is the service layer since that&rsquo;s where all the actual &ldquo;programming&rdquo; is. In order to test that I would have to mock
my repository interface and have it return arbitrary fake data without actually using the database. You can imagine how bad of an idea it would be
if someone was to test creations, updates or deletions while using the actual database&hellip;</p>
<p>There are some other options such as using a different, in memory database for testing but we will not be covering that in this post.</p>
<p>So back to our test, how do we mock the dependency?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// UnitTest1.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> FakeItEasy;
<span style="color:#66d9ef">using</span> src.Services;
<span style="color:#66d9ef">using</span> Xunit;

<span style="color:#66d9ef">namespace</span> test
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnitTest1</span>
    {
<span style="color:#a6e22e">        [Fact]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task Test1()
        {
            <span style="color:#66d9ef">var</span> myDependency = <span style="color:#66d9ef">new</span> MyDependency();
            Assert.Equal(<span style="color:#e6db74">&#34;Hello From MyDependency!&#34;</span>, <span style="color:#66d9ef">await</span> myDependency.GetDataFromDatabaseAsync());
        }
<span style="color:#a6e22e">        
</span><span style="color:#a6e22e">        [Fact]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task Test2()
        {
            <span style="color:#66d9ef">var</span> myDependency = A.Fake&lt;IMyDependency&gt;();
            A.CallTo(() =&gt; myDependency.GetDataFromDatabaseAsync()).Returns(Task.FromResult(<span style="color:#e6db74">&#34;Hello from mocked&#34;</span>));
            
            Assert.Equal(<span style="color:#e6db74">&#34;Hello from mocked&#34;</span>, <span style="color:#66d9ef">await</span> myDependency.GetDataFromDatabaseAsync());
        }
    }
}
</code></pre></div><p>Using the <code>FakeItEasy</code> package we define an instance of the <code>IMyDependency</code> interface using <code>A.Fake</code>. This right now does nothing;
we have to explicitly define what happens when one of the interface methods gets called, we do that with <code>A.CallTo</code>  which accepts a lambda
of the method in question. I am using <code>Task.FromResult</code> because the method is async. If we run the test we can see that it passes which means that
we successfully changed the &ldquo;implementation&rdquo; of our dependency. Again, this is what would normally be a repository and a database call changed to
hard coded data, similar to what would be returned from said database call.</p>
<h2 id="adding-a-ci-pipeline-with-codecov">Adding a CI pipeline with Codecov</h2>
<p>Another thing we could do is add Codecov to get a detailed view of our test coverage. The best way to do that in my
opinion is to create a Continuous Integration (CI) pipeline on Github that will generate and push code coverage information everytime we update
the repository.</p>
<p>First go to Codecov&rsquo;s website and create an account. Get your <code>CODECOV_TOKEN</code> and create a repository secret with its value on your github
repository, we will be using this later when we push our data to Codecov.</p>
<p>We also need to create a <code>codecov.yml</code> file with some basic configuration. Here&rsquo;s what I had from a previous project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#75715e"># codecov.yml</span>
<span style="color:#f92672">comment</span>: <span style="color:#66d9ef">false</span>

<span style="color:#f92672">ignore</span>:
  - <span style="color:#e6db74">&#34;^(?!.*Services).*$&#34;</span>

<span style="color:#f92672">coverage</span>:
  <span style="color:#f92672">status</span>:
    <span style="color:#f92672">project</span>:
      <span style="color:#f92672">default</span>:
        <span style="color:#f92672">target</span>: <span style="color:#ae81ff">auto</span>
        <span style="color:#f92672">threshold</span>: <span style="color:#ae81ff">1</span><span style="color:#ae81ff">%</span>
        <span style="color:#f92672">informational</span>: <span style="color:#66d9ef">true</span>
    <span style="color:#f92672">patch</span>:
      <span style="color:#f92672">default</span>:
        <span style="color:#f92672">target</span>: <span style="color:#ae81ff">auto</span>
        <span style="color:#f92672">threshold</span>: <span style="color:#ae81ff">1</span><span style="color:#ae81ff">%</span>
        <span style="color:#f92672">informational</span>: <span style="color:#66d9ef">true</span>
</code></pre></div><p>The only interesting thing about this is that I ignored every folder that does not include <code>Services</code> since that&rsquo;s the only thing we tested.</p>
<p>Let&rsquo;s create the <code>.github/workflows/dotnet.yml</code> file and use the Github Actions template for .NET apps which includes building and testing.
We only have to add one more step for codecov to work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#75715e"># dotnet.yml</span>
<span style="color:#f92672">name</span>: <span style="color:#ae81ff">.NET</span>

<span style="color:#f92672">on</span>:
  <span style="color:#f92672">push</span>:
    <span style="color:#f92672">branches</span>: [ <span style="color:#ae81ff">master ]</span>
  <span style="color:#f92672">pull_request</span>:
    <span style="color:#f92672">branches</span>: [ <span style="color:#ae81ff">master ]</span>

<span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">build</span>:

    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>

    <span style="color:#f92672">steps</span>:
    - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v2</span>
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Setup .NET</span>
      <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/setup-dotnet@v1</span>
      <span style="color:#f92672">with</span>:
        <span style="color:#f92672">dotnet-version</span>: <span style="color:#ae81ff">5.0</span><span style="color:#ae81ff">.x</span>
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore dependencies</span>
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dotnet restore</span>
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Build</span>
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dotnet build --no-restore</span>
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Test</span>
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">dotnet test --no-build --verbosity normal --collect:&#34;XPlat Code Coverage&#34; -- IncludeDirectory=&#34;[.]*Services[.]*&#34;</span>
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Codecov</span>
      <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">codecov/codecov-action@v2</span>
      <span style="color:#f92672">with</span>:
        <span style="color:#f92672">token</span>: <span style="color:#ae81ff">${{ secrets.CODECOV_TOKEN }}</span>
</code></pre></div><p>The <a href="https://github.com/codecov/codecov-action">Codecov action</a> offers a few useful parameters for you to use so if you are interested,
read their docs!</p>
<p>With all this done and pushed you just want to wait for the Action to complete. After that&rsquo;s done I can take a look at my coverage</p>
<p><img loading="lazy" src="images/codecov.png#center" alt="codecov"  />
</p>
<p>This is very useful to look at when dealing when <em>more than one directory unlike here</em>.</p>
<p>You can also take a look at the exact spots in your code that you tested/missed</p>
<p><img loading="lazy" src="images/code.png#center" alt="code"  />
</p>
<p>And finally (but certainly most importantly), codecov gives you a badge to display on your Github repo to show everyone how well tested your code
is. What&rsquo;s the point of testing if you don&rsquo;t let everyone know you did after all?</p>
<h1 id="conclusion">Conclusion</h1>
<p>Testing is basically essential to any application that is not yet another personal project doomed to be abandoned a few weeks after its inception.
If you decide to test your project I do not see why you wouldn&rsquo;t include coverage reports, whether automated or not. Codecov (and other similar tools)
allow you to set a lot of rules that would fail your pipeline if not met such as: minimum coverage, a minimum threshold of allowed coverage drop on new
commits and a lot more.</p>
<p>I hope you got something out of this post and thanks for reading! :)</p>
<p>You can find the code <a href="https://github.com/AntoniosBarotsis/TestingAPI">here</a>.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>C# and the ELK stack</title>
      <link>https://antoniosbarotsis.github.io/Blog/posts/cs_elk/</link>
      <pubDate>Thu, 28 Oct 2021 22:04:54 +0200</pubDate>
      
      <guid>https://antoniosbarotsis.github.io/Blog/posts/cs_elk/</guid>
      <description>Integrating the ELK stack with C#</description>
      <content:encoded><![CDATA[<h1 id="what-is-the-elk-stack">What is the ELK stack?</h1>
<p>With today&rsquo;s applications growing in complexity rapidly, debugging and efficiently digesting logs have become crucial.
That is the problem that the <a href="https://www.elastic.co/what-is/elk-stack">ELK stack</a> is trying to solve.</p>
<p>The ELK stack consists of:</p>
<ul>
<li>Elasticsearch: A distributed search engine with highly refined analytics capabilities</li>
<li>Logstash: A data-processing pipeline that collects data and delivers it to Elasticsearch</li>
<li>Kibana: A visualization platform built expressly for Elasticsearch</li>
</ul>
<p>These three together make for a great way of digesting aggregated logs from your application through visualisations.</p>
<h1 id="what-will-we-be-creating">What will we be creating?</h1>
<p>We will be making a simple API (the default weather forecast template), have it produce logs using Serilog into elasticsearch and viewing them
through kibana.</p>
<p>For this post I will be assuming you have used C# before and thus you have a ready-to-go set up on your machine.</p>
<h1 id="coding">Coding</h1>
<p>Let&rsquo;s first make our project using the dotnet cli, I will name mine <code>elk</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dotnet new webapi -n elk
</code></pre></div><p>Verify that everything is working fine by running the API</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dotnet run
</code></pre></div><p>and visiting <code>https://localhost:5001/weatherforecast</code>. I am using <a href="https://insomnia.rest/">Insomnia</a> for my http client but Postman or your browser
would also work.</p>
<p><img loading="lazy" src="images/helloWorld.jpg#center" alt="image alt text"  />
</p>
<h2 id="setting-up-middleware">Setting up middleware</h2>
<p>I will be setting up middleware to handle logging as it is a cleaner solution than logging in each request. You can read more about middleware
<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-5.0">here</a>.</p>
<p>I created the following file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// MyMiddleware.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> Microsoft.AspNetCore.Http;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Logging;

<span style="color:#66d9ef">namespace</span> elk
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyMiddleware</span>
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger&lt;MyMiddleware&gt; <span style="color:#ae81ff">_l</span>ogger;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> RequestDelegate <span style="color:#ae81ff">_</span>next;

        <span style="color:#66d9ef">public</span> MyMiddleware(RequestDelegate next, ILogger&lt;MyMiddleware&gt; logger)
        {
            <span style="color:#ae81ff">_</span>next = next;
            <span style="color:#ae81ff">_l</span>ogger = logger;
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task InvokeAsync(HttpContext context)
        {
            <span style="color:#ae81ff">_l</span>ogger.LogInformation(<span style="color:#e6db74">&#34;Hello from middleware&#34;</span>);
            <span style="color:#66d9ef">await</span> <span style="color:#ae81ff">_</span>next(context);
        }
    }
}
</code></pre></div><p>and added the following line to the <code>Configure</code> method in <code>Startup.cs</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// Startup.cs -&gt; Configure
</span><span style="color:#75715e"></span>app.UseMiddleware&lt;MyMiddleware&gt;();
</code></pre></div><p>If we now run the app and make a request to our endpoint we can see <code>Hello from middleware</code> logged to the console.</p>
<p>Knowing that that works lets change the middleware a bit so it can catch and handle exceptions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// MyMiddleware.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> Microsoft.AspNetCore.Http;
<span style="color:#66d9ef">using</span> Microsoft.AspNetCore.Mvc;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Logging;

<span style="color:#66d9ef">namespace</span> elk
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyMiddleware</span>
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger&lt;MyMiddleware&gt; <span style="color:#ae81ff">_l</span>ogger;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> RequestDelegate <span style="color:#ae81ff">_</span>next;

        <span style="color:#66d9ef">public</span> MyMiddleware(RequestDelegate next, ILogger&lt;MyMiddleware&gt; logger)
        {
            <span style="color:#ae81ff">_</span>next = next;
            <span style="color:#ae81ff">_l</span>ogger = logger;
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task InvokeAsync(HttpContext context)
        {
            <span style="color:#66d9ef">try</span>
            {
                <span style="color:#66d9ef">await</span> <span style="color:#ae81ff">_</span>next(context);
            }
            <span style="color:#66d9ef">catch</span> (Exception exception)
            {
                <span style="color:#ae81ff">_l</span>ogger.LogError(exception, <span style="color:#e6db74">&#34;Something went wrong&#34;</span>);
                
                <span style="color:#66d9ef">await</span> HandleExceptionAsync(context, exception);
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Task HandleExceptionAsync(HttpContext context, Exception ex)
        {
            context.Response.StatusCode = <span style="color:#ae81ff">500</span>;
            <span style="color:#66d9ef">return</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;An exception occured&#34;</span>);
        }
    }
}
</code></pre></div><p>If we now run the app again we should see nothing logged in the console. If we add a <code>throw new Exception();</code> statement in our controller
we should get a <code>500</code> Response back saying that an exception occured and also see the exception logged in the terminal.</p>
<p>I am going to add the following to the controller so we get errors at random from the endpoint</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#66d9ef">if</span> (rng.Next(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>) &lt; <span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Exception();
</code></pre></div><h2 id="setting-up-the-elasticsearch-and-kibana-containers">Setting up the Elasticsearch and Kibana containers</h2>
<p>I will be using Docker to run Elasticsearch and Kibana so first thing I want to do is make a <code>docker-compose.yml</code> file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#75715e"># docker-compose.yml</span>
<span style="color:#f92672">version</span>: <span style="color:#e6db74">&#34;2.4&#34;</span>
<span style="color:#f92672">services</span>:
  <span style="color:#f92672">es</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">docker.elastic.co/elasticsearch/elasticsearch:7.14.2</span>
    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">es</span>
    <span style="color:#f92672">ports</span>:
      - <span style="color:#e6db74">&#34;9200:9200&#34;</span>
    <span style="color:#f92672">cpu_count</span>: <span style="color:#ae81ff">1</span>
    <span style="color:#f92672">mem_limit</span>: <span style="color:#ae81ff">4g</span>
    <span style="color:#f92672">ulimits</span>:
      <span style="color:#f92672">memlock</span>:
        <span style="color:#f92672">soft</span>: -<span style="color:#ae81ff">1</span>
        <span style="color:#f92672">hard</span>: -<span style="color:#ae81ff">1</span>
      <span style="color:#f92672">nofile</span>:
        <span style="color:#f92672">soft</span>: <span style="color:#ae81ff">65536</span>
        <span style="color:#f92672">hard</span>: <span style="color:#ae81ff">65536</span>
    <span style="color:#f92672">environment</span>:
      - <span style="color:#ae81ff">cluster.name=es-docker</span>
      - <span style="color:#ae81ff">cluster.initial_master_nodes=node1</span>
      - <span style="color:#ae81ff">node.name=node1</span>
      - <span style="color:#ae81ff">bootstrap.memory_lock=true</span>
      - <span style="color:#e6db74">&#34;ES_JAVA_OPTS=-Xms2g -Xmx2g&#34;</span>
  <span style="color:#f92672">kib</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">docker.elastic.co/kibana/kibana:7.14.2</span>
    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">kib</span>
    <span style="color:#f92672">ports</span>:
      - <span style="color:#e6db74">&#34;5601:5601&#34;</span>
    <span style="color:#f92672">depends_on</span>:
      - <span style="color:#ae81ff">es</span>
    <span style="color:#f92672">cpu_count</span>: <span style="color:#ae81ff">1</span>
    <span style="color:#f92672">mem_limit</span>: <span style="color:#ae81ff">4g</span>
    <span style="color:#f92672">environment</span>: 
      <span style="color:#f92672">ELASTICSEARCH_URL</span>: <span style="color:#ae81ff">http://es:9200</span>
      <span style="color:#f92672">ELASTICSEARCH_HOSTS</span>: <span style="color:#ae81ff">http://es:9200</span>
</code></pre></div><p>A few things about this;</p>
<ul>
<li>It seems that at the time of writing this, version 3 does not support resource limits without using swarm hence the downgrade to 2.4
(please use resource limits if you want your computer to be usable)</li>
<li>The <code>cluster.initial_master_nodes</code> and <code>node.name</code> must have the same value as I want to use a one node cluster</li>
<li>The <code>ELASTICSEARCH_URL</code> and <code>ELASTICSEARCH_HOSTS</code> params are needed since by default these will try to find the elasticsearch server at
<code>http://localhost:9200</code>.</li>
</ul>
<h2 id="setting-up-serilog">Setting up Serilog</h2>
<p>We will be using the <code>Serilog.AspNetCore</code> (for logging), <code>Serilog.Sinks.Elasticsearch</code> (for pushing our logs to elastic) and
<code>Serilog.Enricher.Environment</code> (for adding properties from System.Environment) packages.</p>
<p>Once you have those installed, go to the <code>appsettings.json</code> file, remove the Logging section and add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#e6db74">&#34;Serilog&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
  <span style="color:#f92672">&#34;MinimumLevel&#34;</span>: {
    <span style="color:#f92672">&#34;Default&#34;</span>: <span style="color:#e6db74">&#34;Information&#34;</span>,
    <span style="color:#f92672">&#34;Override&#34;</span>: {
      <span style="color:#f92672">&#34;Microsoft&#34;</span>: <span style="color:#e6db74">&#34;Information&#34;</span>,
      <span style="color:#f92672">&#34;System&#34;</span>: <span style="color:#e6db74">&#34;Warning&#34;</span>
    }
  }
}
</code></pre></div><p>We need to make some changes in our <code>Program.cs</code> file both for logging in the terminal as well as pushing our logs to Elastic.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// Program.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IHostBuilder CreateHostBuilder(<span style="color:#66d9ef">string</span>[] args)
{
    <span style="color:#66d9ef">return</span> Host.CreateDefaultBuilder(args)
        .UseSerilog((context, configuration) =&gt;
        {
            configuration
                .Enrich.FromLogContext()
                .Enrich.WithMachineName()
                .WriteTo.Console()
                .WriteTo.Elasticsearch(
                    <span style="color:#66d9ef">new</span> ElasticsearchSinkOptions(<span style="color:#66d9ef">new</span> Uri(context.Configuration[<span style="color:#e6db74">&#34;ElasticConfig:url&#34;</span>]))
                    {
                        IndexFormat = <span style="color:#e6db74">$&#34;{System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}-&#34;</span> +
                                      <span style="color:#e6db74">$&#34;{context.Configuration[&#34;</span>ASPNETCORE_ENVIRONMENT<span style="color:#e6db74">&#34;].ToLower()}_{DateTime.UtcNow:yyyy-MM-dd}&#34;</span>,
                        AutoRegisterTemplate = <span style="color:#66d9ef">true</span>
                    })
                .Enrich.WithProperty(<span style="color:#e6db74">&#34;Environment&#34;</span>, context.HostingEnvironment.EnvironmentName)
                .ReadFrom.Configuration(context.Configuration);
        })
        .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });
}
</code></pre></div><p>Most of this you can find online but for as a short explanation:</p>
<ul>
<li>We enrich our logs with the log context, machine name and the environment (dev/prod)</li>
<li>We push our logs both to the console and to elastic</li>
<li>The logs in elastic will have the format <code>appname-dev/prod_date</code>. Something to keep in mind for this is that it looks like some characters
like <code>:</code> do not work in these patterns or at least didn&rsquo;t work for me hence the underscore.</li>
</ul>
<p>What&rsquo;s cool about this is that we do not have to change our existing logger related code! We can also however use Serilog directly:</p>
<ul>
<li>Change the <code>using Microsoft.Extensions.Logging;</code> import to <code>using Serilog;</code></li>
<li>Remove the generic from the <code>ILogger</code>s</li>
<li>Change <code>_logger.LogError</code> to <code>_logger.Error</code></li>
</ul>
<p>Another thing we can do is edit the Exception data and log some debugging critical parameter.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// WeatherForecastController.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (rng.Next(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>) &lt; <span style="color:#ae81ff">2</span>)
{
    <span style="color:#66d9ef">var</span> myException = <span style="color:#66d9ef">new</span> Exception();
    myException.Data.Add(<span style="color:#e6db74">&#34;someVeryImportantAttribute&#34;</span>, <span style="color:#ae81ff">42</span>);
    <span style="color:#66d9ef">throw</span> myException;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#75715e">// MyMiddleware.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">catch</span> (Exception exception)
{
    <span style="color:#ae81ff">_l</span>ogger.Error(exception, <span style="color:#e6db74">&#34;Something went wrong, {message}&#34;</span>, exception.Data[<span style="color:#e6db74">&#34;someVeryImportantAttribute&#34;</span>]);
    
    <span style="color:#66d9ef">await</span> HandleExceptionAsync(context, exception);
}
</code></pre></div><p>If we now run the app logs will start getting pushed to elastic (make sure to also make a few requests so you get some errors!).</p>
<h2 id="kibana">Kibana</h2>
<p>We can now visit <code>http://localhost:5601</code> to access kibana.</p>
<p>Once there, go to <code>Spaces &gt; Manage Spaces</code> from the top right and select default. On the left you should see <code>Index patterns</code> and if you go there
you can essentially define the log pattern that you want kibana to consider, in my case that is <code>elk-development_*</code>. We can then go to
<code>Analytics &gt; Discover</code> and voil√†!</p>
<p><img loading="lazy" src="images/logs.jpg#center" alt="logs"  />
</p>
<p>If you made the Exception data change mentioned earlier you should be able to see that as well</p>
<p><img loading="lazy" src="images/data.jpg#center" alt="data"  />
</p>
<p>The true power of this comes from how you can query your logs. You could for example query for <code>level: Error</code> to get all your error logs</p>
<p><img loading="lazy" src="images/errors.jpg#center" alt="logs"  />
</p>
<p>You could also make queries like <code>fields.ElapsedMilliseconds &gt; 10</code> or <code>fields.RequestPath: /weatherforecast</code>, you can read more about the
possible queries <a href="https://www.elastic.co/guide/en/kibana/current/kuery-query.html">here</a>.</p>
<p>One thing I always love spending way too much time on is visualizations and I can definitely see this being the most powerful feature in
Kibana</p>
<p><img loading="lazy" src="images/plots.jpg#center" alt="plots"  />
</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall I think this was a pretty cool learning experience for me as I had never done proper error handling or used middleware before in
C# (or used docker hardware limits but we do not talk about that). I think that although I definitely see the ELK stack being invaluable
to a big company, I feel like I will not be using or recommend others to use if for small or personal projects as it is relatively hard
to set up locally and expensive to host (especially if before this you just had a single app instance running).</p>
<p>Long story short; it is definitely pretty cool but like normal logging should be enough for the majority of cases üëç.</p>
<p>And of course by no means will implementing all of this compensate for bad error handling.</p>
<p>Thanks for reading!</p>
<p>You can find the code <a href="https://github.com/AntoniosBarotsis/elk">here</a>.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>